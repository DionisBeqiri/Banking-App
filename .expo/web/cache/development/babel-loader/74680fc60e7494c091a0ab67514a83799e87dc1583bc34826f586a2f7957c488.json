{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport * as React from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport Animated from 'react-native-reanimated';\nimport TabBarItem from \"./TabBarItem\";\nimport TabBarIndicator from \"./TabBarIndicator\";\nimport memoize from \"./memoize\";\nvar scheduleInNextFrame = function scheduleInNextFrame(cb) {\n  var frame = requestAnimationFrame(function () {\n    frame = requestAnimationFrame(cb);\n  });\n  return function () {\n    return cancelAnimationFrame(frame);\n  };\n};\nvar TabBar = function (_React$Component) {\n  function TabBar() {\n    var _this;\n    _classCallCheck(this, TabBar);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = _callSuper(this, TabBar, [].concat(args));\n    _defineProperty(_this, \"state\", {\n      layout: {\n        width: 0,\n        height: 0\n      },\n      tabWidths: {}\n    });\n    _defineProperty(_this, \"measuredTabWidths\", {});\n    _defineProperty(_this, \"scrollAmount\", new Animated.Value(0));\n    _defineProperty(_this, \"scrollViewRef\", React.createRef());\n    _defineProperty(_this, \"cancelNextFrameCb\", undefined);\n    _defineProperty(_this, \"getFlattenedTabWidth\", function (style) {\n      var tabStyle = StyleSheet.flatten(style);\n      return tabStyle ? tabStyle.width : undefined;\n    });\n    _defineProperty(_this, \"getComputedTabWidth\", function (index, layout, routes, scrollEnabled, tabWidths, flattenedWidth) {\n      if (flattenedWidth === 'auto') {\n        return tabWidths[routes[index].key] || 0;\n      }\n      switch (typeof flattenedWidth) {\n        case 'number':\n          return flattenedWidth;\n        case 'string':\n          if (flattenedWidth.endsWith('%')) {\n            var width = parseFloat(flattenedWidth);\n            if (Number.isFinite(width)) {\n              return layout.width * (width / 100);\n            }\n          }\n      }\n      if (scrollEnabled) {\n        return layout.width / 5 * 2;\n      }\n      return layout.width / routes.length;\n    });\n    _defineProperty(_this, \"getMemoizedTabWidthGettter\", memoize(function (layout, routes, scrollEnabled, tabWidths, flattenedWidth) {\n      return function (i) {\n        return _this.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, flattenedWidth);\n      };\n    }));\n    _defineProperty(_this, \"getMaxScrollDistance\", function (tabBarWidth, layoutWidth) {\n      return tabBarWidth - layoutWidth;\n    });\n    _defineProperty(_this, \"getTabBarWidth\", function (props, state) {\n      var layout = state.layout,\n        tabWidths = state.tabWidths;\n      var scrollEnabled = props.scrollEnabled,\n        tabStyle = props.tabStyle;\n      var routes = props.navigationState.routes;\n      return routes.reduce(function (acc, _, i) {\n        return acc + _this.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this.getFlattenedTabWidth(tabStyle));\n      }, 0);\n    });\n    _defineProperty(_this, \"normalizeScrollValue\", function (props, state, value) {\n      var layout = state.layout;\n      var tabBarWidth = _this.getTabBarWidth(props, state);\n      var maxDistance = _this.getMaxScrollDistance(tabBarWidth, layout.width);\n      var scrollValue = Math.max(Math.min(value, maxDistance), 0);\n      if (Platform.OS === 'android' && I18nManager.isRTL) {\n        return maxDistance - scrollValue;\n      }\n      return scrollValue;\n    });\n    _defineProperty(_this, \"getScrollAmount\", function (props, state, index) {\n      var layout = state.layout,\n        tabWidths = state.tabWidths;\n      var scrollEnabled = props.scrollEnabled,\n        tabStyle = props.tabStyle;\n      var routes = props.navigationState.routes;\n      var centerDistance = Array.from({\n        length: index + 1\n      }).reduce(function (total, _, i) {\n        var tabWidth = _this.getComputedTabWidth(i, layout, routes, scrollEnabled, tabWidths, _this.getFlattenedTabWidth(tabStyle));\n        return total + (index === i ? tabWidth / 2 : tabWidth);\n      }, 0);\n      var scrollAmount = centerDistance - layout.width / 2;\n      return _this.normalizeScrollValue(props, state, scrollAmount);\n    });\n    _defineProperty(_this, \"resetScroll\", function (index) {\n      if (_this.props.scrollEnabled) {\n        var _this$scrollViewRef$c, _this$scrollViewRef$c2;\n        var scrollView = typeof ((_this$scrollViewRef$c = _this.scrollViewRef.current) === null || _this$scrollViewRef$c === void 0 ? void 0 : _this$scrollViewRef$c.scrollTo) === 'function' ? _this.scrollViewRef.current : (_this$scrollViewRef$c2 = _this.scrollViewRef.current) === null || _this$scrollViewRef$c2 === void 0 ? void 0 : _this$scrollViewRef$c2.getNode();\n        scrollView === null || scrollView === void 0 ? void 0 : scrollView.scrollTo({\n          x: _this.getScrollAmount(_this.props, _this.state, index),\n          animated: true\n        });\n      }\n    });\n    _defineProperty(_this, \"handleLayout\", function (e) {\n      var _this$cancelNextFrame;\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n        height = _e$nativeEvent$layout.height,\n        width = _e$nativeEvent$layout.width;\n      if (_this.state.layout.width === width && _this.state.layout.height === height) {\n        return;\n      }\n      (_this$cancelNextFrame = _this.cancelNextFrameCb) === null || _this$cancelNextFrame === void 0 ? void 0 : _this$cancelNextFrame.call(_this);\n      _this.cancelNextFrameCb = scheduleInNextFrame(function () {\n        return _this.setState({\n          layout: {\n            height: height,\n            width: width\n          }\n        });\n      });\n    });\n    _defineProperty(_this, \"getTranslateX\", memoize(function (scrollAmount, maxScrollDistance) {\n      return Animated.multiply(Platform.OS === 'android' && I18nManager.isRTL ? Animated.sub(maxScrollDistance, scrollAmount) : scrollAmount, I18nManager.isRTL ? 1 : -1);\n    }));\n    return _this;\n  }\n  _inherits(TabBar, _React$Component);\n  return _createClass(TabBar, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var navigationState = this.props.navigationState;\n      var _this$state = this.state,\n        layout = _this$state.layout,\n        tabWidths = _this$state.tabWidths;\n      if (prevProps.navigationState.routes.length !== navigationState.routes.length || prevProps.navigationState.index !== navigationState.index || prevState.layout.width !== layout.width || prevState.tabWidths !== tabWidths) {\n        if (this.getFlattenedTabWidth(this.props.tabStyle) === 'auto' && !(layout.width && navigationState.routes.every(function (r) {\n          return typeof tabWidths[r.key] === 'number';\n        }))) {\n          return;\n        }\n        this.resetScroll(navigationState.index);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$cancelNextFrame2;\n      (_this$cancelNextFrame2 = this.cancelNextFrameCb) === null || _this$cancelNextFrame2 === void 0 ? void 0 : _this$cancelNextFrame2.call(this);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n      var _this$props = this.props,\n        position = _this$props.position,\n        navigationState = _this$props.navigationState,\n        jumpTo = _this$props.jumpTo,\n        scrollEnabled = _this$props.scrollEnabled,\n        bounces = _this$props.bounces,\n        getAccessibilityLabel = _this$props.getAccessibilityLabel,\n        getAccessible = _this$props.getAccessible,\n        getLabelText = _this$props.getLabelText,\n        getTestID = _this$props.getTestID,\n        renderBadge = _this$props.renderBadge,\n        renderIcon = _this$props.renderIcon,\n        renderLabel = _this$props.renderLabel,\n        renderTabBarItem = _this$props.renderTabBarItem,\n        activeColor = _this$props.activeColor,\n        inactiveColor = _this$props.inactiveColor,\n        pressColor = _this$props.pressColor,\n        pressOpacity = _this$props.pressOpacity,\n        onTabPress = _this$props.onTabPress,\n        onTabLongPress = _this$props.onTabLongPress,\n        tabStyle = _this$props.tabStyle,\n        labelStyle = _this$props.labelStyle,\n        indicatorStyle = _this$props.indicatorStyle,\n        contentContainerStyle = _this$props.contentContainerStyle,\n        style = _this$props.style,\n        indicatorContainerStyle = _this$props.indicatorContainerStyle;\n      var _this$state2 = this.state,\n        layout = _this$state2.layout,\n        tabWidths = _this$state2.tabWidths;\n      var routes = navigationState.routes;\n      var isWidthDynamic = this.getFlattenedTabWidth(tabStyle) === 'auto';\n      var tabBarWidth = this.getTabBarWidth(this.props, this.state);\n      var tabBarWidthPercent = \"\".concat(routes.length * 40, \"%\");\n      var translateX = this.getTranslateX(this.scrollAmount, this.getMaxScrollDistance(tabBarWidth, layout.width));\n      return React.createElement(Animated.View, {\n        onLayout: this.handleLayout,\n        style: [styles.tabBar, style]\n      }, React.createElement(Animated.View, {\n        pointerEvents: \"none\",\n        style: [styles.indicatorContainer, scrollEnabled ? {\n          transform: [{\n            translateX: translateX\n          }]\n        } : null, tabBarWidth ? {\n          width: tabBarWidth\n        } : scrollEnabled ? {\n          width: tabBarWidthPercent\n        } : null, indicatorContainerStyle]\n      }, this.props.renderIndicator({\n        position: position,\n        layout: layout,\n        navigationState: navigationState,\n        jumpTo: jumpTo,\n        width: isWidthDynamic ? 'auto' : \"\".concat(100 / routes.length, \"%\"),\n        style: indicatorStyle,\n        getTabWidth: this.getMemoizedTabWidthGettter(layout, routes, scrollEnabled, tabWidths, this.getFlattenedTabWidth(tabStyle))\n      })), React.createElement(View, {\n        style: styles.scroll\n      }, React.createElement(Animated.ScrollView, {\n        horizontal: true,\n        accessibilityRole: \"tablist\",\n        keyboardShouldPersistTaps: \"handled\",\n        scrollEnabled: scrollEnabled,\n        bounces: bounces,\n        alwaysBounceHorizontal: false,\n        scrollsToTop: false,\n        showsHorizontalScrollIndicator: false,\n        automaticallyAdjustContentInsets: false,\n        overScrollMode: \"never\",\n        contentContainerStyle: [styles.tabContent, scrollEnabled ? {\n          width: tabBarWidth || tabBarWidthPercent\n        } : styles.container, contentContainerStyle],\n        scrollEventThrottle: 16,\n        onScroll: Animated.event([{\n          nativeEvent: {\n            contentOffset: {\n              x: this.scrollAmount\n            }\n          }\n        }]),\n        ref: this.scrollViewRef\n      }, routes.map(function (route) {\n        var props = {\n          key: route.key,\n          position: position,\n          route: route,\n          navigationState: navigationState,\n          getAccessibilityLabel: getAccessibilityLabel,\n          getAccessible: getAccessible,\n          getLabelText: getLabelText,\n          getTestID: getTestID,\n          renderBadge: renderBadge,\n          renderIcon: renderIcon,\n          renderLabel: renderLabel,\n          activeColor: activeColor,\n          inactiveColor: inactiveColor,\n          pressColor: pressColor,\n          pressOpacity: pressOpacity,\n          onLayout: isWidthDynamic ? function (e) {\n            _this2.measuredTabWidths[route.key] = e.nativeEvent.layout.width;\n            if (routes.every(function (r) {\n              return typeof _this2.measuredTabWidths[r.key] === 'number';\n            })) {\n              _this2.setState({\n                tabWidths: _objectSpread({}, _this2.measuredTabWidths)\n              });\n            }\n          } : undefined,\n          onPress: function onPress() {\n            var event = {\n              route: route,\n              defaultPrevented: false,\n              preventDefault: function preventDefault() {\n                event.defaultPrevented = true;\n              }\n            };\n            onTabPress === null || onTabPress === void 0 ? void 0 : onTabPress(event);\n            if (event.defaultPrevented) {\n              return;\n            }\n            _this2.props.jumpTo(route.key);\n          },\n          onLongPress: function onLongPress() {\n            return onTabLongPress === null || onTabLongPress === void 0 ? void 0 : onTabLongPress({\n              route: route\n            });\n          },\n          labelStyle: labelStyle,\n          style: tabStyle\n        };\n        return renderTabBarItem ? renderTabBarItem(props) : React.createElement(TabBarItem, props);\n      }))));\n    }\n  }]);\n}(React.Component);\nexport { TabBar as default };\n_defineProperty(TabBar, \"defaultProps\", {\n  getLabelText: function getLabelText(_ref) {\n    var route = _ref.route;\n    return typeof route.title === 'string' ? route.title.toUpperCase() : route.title;\n  },\n  getAccessible: function getAccessible(_ref2) {\n    var route = _ref2.route;\n    return typeof route.accessible !== 'undefined' ? route.accessible : true;\n  },\n  getAccessibilityLabel: function getAccessibilityLabel(_ref3) {\n    var route = _ref3.route;\n    return typeof route.accessibilityLabel === 'string' ? route.accessibilityLabel : typeof route.title === 'string' ? route.title : undefined;\n  },\n  getTestID: function getTestID(_ref4) {\n    var route = _ref4.route;\n    return route.testID;\n  },\n  renderIndicator: function renderIndicator(props) {\n    return React.createElement(TabBarIndicator, props);\n  }\n});\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  scroll: {\n    overflow: Platform.select({\n      default: 'scroll',\n      web: undefined\n    })\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0\n    },\n    zIndex: 1\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap'\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }\n});","map":{"version":3,"names":["React","StyleSheet","View","I18nManager","Platform","Animated","TabBarItem","TabBarIndicator","memoize","scheduleInNextFrame","cb","frame","requestAnimationFrame","cancelAnimationFrame","TabBar","_React$Component","_this","_classCallCheck","_len","arguments","length","args","Array","_key","_callSuper","concat","_defineProperty","layout","width","height","tabWidths","Value","createRef","undefined","style","tabStyle","flatten","index","routes","scrollEnabled","flattenedWidth","key","endsWith","parseFloat","Number","isFinite","i","getComputedTabWidth","tabBarWidth","layoutWidth","props","state","navigationState","reduce","acc","_","getFlattenedTabWidth","value","getTabBarWidth","maxDistance","getMaxScrollDistance","scrollValue","Math","max","min","OS","isRTL","centerDistance","from","total","tabWidth","scrollAmount","normalizeScrollValue","_this$scrollViewRef$c","_this$scrollViewRef$c2","scrollView","scrollViewRef","current","scrollTo","getNode","x","getScrollAmount","animated","e","_this$cancelNextFrame","_e$nativeEvent$layout","nativeEvent","cancelNextFrameCb","call","setState","maxScrollDistance","multiply","sub","_inherits","_createClass","componentDidUpdate","prevProps","prevState","_this$state","every","r","resetScroll","componentWillUnmount","_this$cancelNextFrame2","render","_this2","_this$props","position","jumpTo","bounces","getAccessibilityLabel","getAccessible","getLabelText","getTestID","renderBadge","renderIcon","renderLabel","renderTabBarItem","activeColor","inactiveColor","pressColor","pressOpacity","onTabPress","onTabLongPress","labelStyle","indicatorStyle","contentContainerStyle","indicatorContainerStyle","_this$state2","isWidthDynamic","tabBarWidthPercent","translateX","getTranslateX","createElement","onLayout","handleLayout","styles","tabBar","pointerEvents","indicatorContainer","transform","renderIndicator","getTabWidth","getMemoizedTabWidthGettter","scroll","ScrollView","horizontal","accessibilityRole","keyboardShouldPersistTaps","alwaysBounceHorizontal","scrollsToTop","showsHorizontalScrollIndicator","automaticallyAdjustContentInsets","overScrollMode","tabContent","container","scrollEventThrottle","onScroll","event","contentOffset","ref","map","route","measuredTabWidths","_objectSpread","onPress","defaultPrevented","preventDefault","onLongPress","Component","default","_ref","title","toUpperCase","_ref2","accessible","_ref3","accessibilityLabel","_ref4","testID","create","flex","overflow","select","web","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","zIndex","flexDirection","flexWrap","top","left","right","bottom"],"sources":["C:\\Users\\pc\\Desktop\\React\\rn-starter\\node_modules\\react-native-tab-view\\lib\\module\\TabBar.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  StyleSheet,\n  View,\n  StyleProp,\n  ViewStyle,\n  TextStyle,\n  LayoutChangeEvent,\n  I18nManager,\n  Platform,\n} from 'react-native';\nimport Animated from 'react-native-reanimated';\nimport TabBarItem, { Props as TabBarItemProps } from './TabBarItem';\nimport TabBarIndicator, { Props as IndicatorProps } from './TabBarIndicator';\nimport memoize from './memoize';\nimport {\n  Route,\n  Scene,\n  SceneRendererProps,\n  NavigationState,\n  Layout,\n  Event,\n} from './types';\n\nexport type Props<T extends Route> = SceneRendererProps & {\n  navigationState: NavigationState<T>;\n  scrollEnabled?: boolean;\n  bounces?: boolean;\n  activeColor?: string;\n  inactiveColor?: string;\n  pressColor?: string;\n  pressOpacity?: number;\n  getLabelText: (scene: Scene<T>) => string | undefined;\n  getAccessible: (scene: Scene<T>) => boolean | undefined;\n  getAccessibilityLabel: (scene: Scene<T>) => string | undefined;\n  getTestID: (scene: Scene<T>) => string | undefined;\n  renderLabel?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderIcon?: (\n    scene: Scene<T> & {\n      focused: boolean;\n      color: string;\n    }\n  ) => React.ReactNode;\n  renderBadge?: (scene: Scene<T>) => React.ReactNode;\n  renderIndicator: (props: IndicatorProps<T>) => React.ReactNode;\n  renderTabBarItem?: (\n    props: TabBarItemProps<T> & { key: string }\n  ) => React.ReactElement;\n  onTabPress?: (scene: Scene<T> & Event) => void;\n  onTabLongPress?: (scene: Scene<T>) => void;\n  tabStyle?: StyleProp<ViewStyle>;\n  indicatorStyle?: StyleProp<ViewStyle>;\n  indicatorContainerStyle?: StyleProp<ViewStyle>;\n  labelStyle?: StyleProp<TextStyle>;\n  contentContainerStyle?: StyleProp<ViewStyle>;\n  style?: StyleProp<ViewStyle>;\n};\n\ntype State = {\n  layout: Layout;\n  tabWidths: { [key: string]: number };\n};\n\nconst scheduleInNextFrame = (cb: () => void) => {\n  let frame = requestAnimationFrame(() => {\n    frame = requestAnimationFrame(cb);\n  });\n\n  return () => cancelAnimationFrame(frame);\n};\n\nexport default class TabBar<T extends Route> extends React.Component<\n  Props<T>,\n  State\n> {\n  static defaultProps = {\n    getLabelText: ({ route }: Scene<Route>) =>\n      typeof route.title === 'string' ? route.title.toUpperCase() : route.title,\n    getAccessible: ({ route }: Scene<Route>) =>\n      typeof route.accessible !== 'undefined' ? route.accessible : true,\n    getAccessibilityLabel: ({ route }: Scene<Route>) =>\n      typeof route.accessibilityLabel === 'string'\n        ? route.accessibilityLabel\n        : typeof route.title === 'string'\n        ? route.title\n        : undefined,\n    getTestID: ({ route }: Scene<Route>) => route.testID,\n    renderIndicator: (props: IndicatorProps<Route>) => (\n      <TabBarIndicator {...props} />\n    ),\n  };\n\n  state: State = {\n    layout: { width: 0, height: 0 },\n    tabWidths: {},\n  };\n\n  componentDidUpdate(prevProps: Props<T>, prevState: State) {\n    const { navigationState } = this.props;\n    const { layout, tabWidths } = this.state;\n\n    if (\n      prevProps.navigationState.routes.length !==\n        navigationState.routes.length ||\n      prevProps.navigationState.index !== navigationState.index ||\n      prevState.layout.width !== layout.width ||\n      prevState.tabWidths !== tabWidths\n    ) {\n      if (\n        this.getFlattenedTabWidth(this.props.tabStyle) === 'auto' &&\n        !(\n          layout.width &&\n          navigationState.routes.every(\n            (r) => typeof tabWidths[r.key] === 'number'\n          )\n        )\n      ) {\n        // When tab width is dynamic, only adjust the scroll once we have all tab widths and layout\n        return;\n      }\n\n      this.resetScroll(navigationState.index);\n    }\n  }\n\n  componentWillUnmount() {\n    this.cancelNextFrameCb?.();\n  }\n\n  // to store the layout.width of each tab\n  // when all onLayout's are fired, this would be set in state\n  private measuredTabWidths: { [key: string]: number } = {};\n\n  private scrollAmount = new Animated.Value(0);\n\n  private scrollViewRef = React.createRef<Animated.ScrollView>();\n\n  private cancelNextFrameCb: (() => void) | undefined = undefined;\n\n  private getFlattenedTabWidth = (style: StyleProp<ViewStyle>) => {\n    const tabStyle = StyleSheet.flatten(style);\n\n    return tabStyle ? tabStyle.width : undefined;\n  };\n\n  private getComputedTabWidth = (\n    index: number,\n    layout: Layout,\n    routes: Route[],\n    scrollEnabled: boolean | undefined,\n    tabWidths: { [key: string]: number },\n    flattenedWidth: string | number | undefined\n  ) => {\n    if (flattenedWidth === 'auto') {\n      return tabWidths[routes[index].key] || 0;\n    }\n\n    switch (typeof flattenedWidth) {\n      case 'number':\n        return flattenedWidth;\n      case 'string':\n        if (flattenedWidth.endsWith('%')) {\n          const width = parseFloat(flattenedWidth);\n          if (Number.isFinite(width)) {\n            return layout.width * (width / 100);\n          }\n        }\n    }\n\n    if (scrollEnabled) {\n      return (layout.width / 5) * 2;\n    }\n\n    return layout.width / routes.length;\n  };\n\n  private getMemoizedTabWidthGettter = memoize(\n    (\n      layout: Layout,\n      routes: Route[],\n      scrollEnabled: boolean | undefined,\n      tabWidths: { [key: string]: number },\n      flattenedWidth: string | number | undefined\n    ) => (i: number) =>\n      this.getComputedTabWidth(\n        i,\n        layout,\n        routes,\n        scrollEnabled,\n        tabWidths,\n        flattenedWidth\n      )\n  );\n\n  private getMaxScrollDistance = (tabBarWidth: number, layoutWidth: number) =>\n    tabBarWidth - layoutWidth;\n\n  private getTabBarWidth = (props: Props<T>, state: State) => {\n    const { layout, tabWidths } = state;\n    const { scrollEnabled, tabStyle } = props;\n    const { routes } = props.navigationState;\n\n    return routes.reduce<number>(\n      (acc, _, i) =>\n        acc +\n        this.getComputedTabWidth(\n          i,\n          layout,\n          routes,\n          scrollEnabled,\n          tabWidths,\n          this.getFlattenedTabWidth(tabStyle)\n        ),\n      0\n    );\n  };\n\n  private normalizeScrollValue = (\n    props: Props<T>,\n    state: State,\n    value: number\n  ) => {\n    const { layout } = state;\n    const tabBarWidth = this.getTabBarWidth(props, state);\n    const maxDistance = this.getMaxScrollDistance(tabBarWidth, layout.width);\n    const scrollValue = Math.max(Math.min(value, maxDistance), 0);\n\n    if (Platform.OS === 'android' && I18nManager.isRTL) {\n      // On Android, scroll value is not applied in reverse in RTL\n      // so we need to manually adjust it to apply correct value\n      return maxDistance - scrollValue;\n    }\n\n    return scrollValue;\n  };\n\n  private getScrollAmount = (props: Props<T>, state: State, index: number) => {\n    const { layout, tabWidths } = state;\n    const { scrollEnabled, tabStyle } = props;\n    const { routes } = props.navigationState;\n\n    const centerDistance = Array.from({ length: index + 1 }).reduce<number>(\n      (total, _, i) => {\n        const tabWidth = this.getComputedTabWidth(\n          i,\n          layout,\n          routes,\n          scrollEnabled,\n          tabWidths,\n          this.getFlattenedTabWidth(tabStyle)\n        );\n\n        // To get the current index centered we adjust scroll amount by width of indexes\n        // 0 through (i - 1) and add half the width of current index i\n        return total + (index === i ? tabWidth / 2 : tabWidth);\n      },\n      0\n    );\n\n    const scrollAmount = centerDistance - layout.width / 2;\n\n    return this.normalizeScrollValue(props, state, scrollAmount);\n  };\n\n  private resetScroll = (index: number) => {\n    if (this.props.scrollEnabled) {\n      // getNode() is not necessary in newer versions of React Native\n      const scrollView =\n        // @ts-ignore\n        typeof this.scrollViewRef.current?.scrollTo === 'function'\n          ? this.scrollViewRef.current\n          : this.scrollViewRef.current?.getNode();\n\n      // @ts-ignore\n      scrollView?.scrollTo({\n        x: this.getScrollAmount(this.props, this.state, index),\n        animated: true,\n      });\n    }\n  };\n\n  private handleLayout = (e: LayoutChangeEvent) => {\n    const { height, width } = e.nativeEvent.layout;\n\n    if (\n      this.state.layout.width === width &&\n      this.state.layout.height === height\n    ) {\n      return;\n    }\n\n    // If we don't delay this state update, the UI gets stuck in weird state\n    // Maybe an issue in Reanimated?\n    // https://github.com/satya164/react-native-tab-view/issues/877\n    // Cancel any pending callbacks, since we're scheduling a new one\n    this.cancelNextFrameCb?.();\n    this.cancelNextFrameCb = scheduleInNextFrame(() =>\n      this.setState({\n        layout: {\n          height,\n          width,\n        },\n      })\n    );\n  };\n\n  private getTranslateX = memoize(\n    (scrollAmount: Animated.Node<number>, maxScrollDistance: number) =>\n      Animated.multiply(\n        Platform.OS === 'android' && I18nManager.isRTL\n          ? Animated.sub(maxScrollDistance, scrollAmount)\n          : scrollAmount,\n        I18nManager.isRTL ? 1 : -1\n      )\n  );\n\n  render() {\n    const {\n      position,\n      navigationState,\n      jumpTo,\n      scrollEnabled,\n      bounces,\n      getAccessibilityLabel,\n      getAccessible,\n      getLabelText,\n      getTestID,\n      renderBadge,\n      renderIcon,\n      renderLabel,\n      renderTabBarItem,\n      activeColor,\n      inactiveColor,\n      pressColor,\n      pressOpacity,\n      onTabPress,\n      onTabLongPress,\n      tabStyle,\n      labelStyle,\n      indicatorStyle,\n      contentContainerStyle,\n      style,\n      indicatorContainerStyle,\n    } = this.props;\n    const { layout, tabWidths } = this.state;\n    const { routes } = navigationState;\n\n    const isWidthDynamic = this.getFlattenedTabWidth(tabStyle) === 'auto';\n    const tabBarWidth = this.getTabBarWidth(this.props, this.state);\n    const tabBarWidthPercent = `${routes.length * 40}%`;\n    const translateX = this.getTranslateX(\n      this.scrollAmount,\n      this.getMaxScrollDistance(tabBarWidth, layout.width)\n    );\n\n    return (\n      <Animated.View\n        onLayout={this.handleLayout}\n        style={[styles.tabBar, style]}\n      >\n        <Animated.View\n          pointerEvents=\"none\"\n          style={[\n            styles.indicatorContainer,\n            scrollEnabled ? { transform: [{ translateX }] as any } : null,\n            tabBarWidth\n              ? { width: tabBarWidth }\n              : scrollEnabled\n              ? { width: tabBarWidthPercent }\n              : null,\n            indicatorContainerStyle,\n          ]}\n        >\n          {this.props.renderIndicator({\n            position,\n            layout,\n            navigationState,\n            jumpTo,\n            width: isWidthDynamic ? 'auto' : `${100 / routes.length}%`,\n            style: indicatorStyle,\n            getTabWidth: this.getMemoizedTabWidthGettter(\n              layout,\n              routes,\n              scrollEnabled,\n              tabWidths,\n              this.getFlattenedTabWidth(tabStyle)\n            ),\n          })}\n        </Animated.View>\n        <View style={styles.scroll}>\n          <Animated.ScrollView\n            horizontal\n            accessibilityRole=\"tablist\"\n            keyboardShouldPersistTaps=\"handled\"\n            scrollEnabled={scrollEnabled}\n            bounces={bounces}\n            alwaysBounceHorizontal={false}\n            scrollsToTop={false}\n            showsHorizontalScrollIndicator={false}\n            automaticallyAdjustContentInsets={false}\n            overScrollMode=\"never\"\n            contentContainerStyle={[\n              styles.tabContent,\n              scrollEnabled\n                ? { width: tabBarWidth || tabBarWidthPercent }\n                : styles.container,\n              contentContainerStyle,\n            ]}\n            scrollEventThrottle={16}\n            onScroll={Animated.event([\n              {\n                nativeEvent: {\n                  contentOffset: { x: this.scrollAmount },\n                },\n              },\n            ])}\n            ref={this.scrollViewRef}\n          >\n            {routes.map((route: T) => {\n              const props: TabBarItemProps<T> & { key: string } = {\n                key: route.key,\n                position: position,\n                route: route,\n                navigationState: navigationState,\n                getAccessibilityLabel: getAccessibilityLabel,\n                getAccessible: getAccessible,\n                getLabelText: getLabelText,\n                getTestID: getTestID,\n                renderBadge: renderBadge,\n                renderIcon: renderIcon,\n                renderLabel: renderLabel,\n                activeColor: activeColor,\n                inactiveColor: inactiveColor,\n                pressColor: pressColor,\n                pressOpacity: pressOpacity,\n                onLayout: isWidthDynamic\n                  ? (e) => {\n                      this.measuredTabWidths[route.key] =\n                        e.nativeEvent.layout.width;\n\n                      // When we have measured widths for all of the tabs, we should updates the state\n                      // We avoid doing separate setState for each layout since it triggers multiple renders and slows down app\n                      if (\n                        routes.every(\n                          (r) =>\n                            typeof this.measuredTabWidths[r.key] === 'number'\n                        )\n                      ) {\n                        this.setState({\n                          tabWidths: { ...this.measuredTabWidths },\n                        });\n                      }\n                    }\n                  : undefined,\n                onPress: () => {\n                  const event: Scene<T> & Event = {\n                    route,\n                    defaultPrevented: false,\n                    preventDefault: () => {\n                      event.defaultPrevented = true;\n                    },\n                  };\n\n                  onTabPress?.(event);\n\n                  if (event.defaultPrevented) {\n                    return;\n                  }\n\n                  this.props.jumpTo(route.key);\n                },\n                onLongPress: () => onTabLongPress?.({ route }),\n                labelStyle: labelStyle,\n                style: tabStyle,\n              };\n\n              return renderTabBarItem ? (\n                renderTabBarItem(props)\n              ) : (\n                <TabBarItem {...props} />\n              );\n            })}\n          </Animated.ScrollView>\n        </View>\n      </Animated.View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scroll: {\n    overflow: Platform.select({ default: 'scroll', web: undefined }),\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n      width: 0,\n    },\n    zIndex: 1,\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}